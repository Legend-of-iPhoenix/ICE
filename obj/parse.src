; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\PARSE.C"
	.assume ADL=1
	SEGMENT TEXT
_implementedFunctions:
	DB	179
	DB	184
	DB	50
	DB	26
	DB	25
	DB	33
	DB	188
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <math.h>
;    6	#include <stdio.h>
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <debug.h>
;   10	
;   11	#include <fileioc.h>
;   12	#include <graphx.h>
;   13	
;   14	#include "parse.h"
;   15	#include "main.h"
;   16	#include "errors.h"
;   17	#include "output.h"
;   18	#include "operator.h"
;   19	#include "stack.h"
;   20	
;   21	extern uint8_t (*functions[256])(unsigned int token);
;   22	const char implementedFunctions[] = {tDet, tNot, tRemainder, tMin, tMax, tMean, tSqrt};
	SEGMENT CODE
;   23	
;   24	unsigned int getc(void) {
_getc:
;   25	    return ti_GetC(ice.inPrgm);
	LD	A,(_ice+40833)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetC
	POP	BC
;   26	}
	RET	


;**************************** _getc ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  40840   variable
;_ti_GetC                            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;   27	
;   28	uint8_t parseProgram(void) {
_parseProgram:
	LD	HL,-4
	CALL	__frameset
;   29	    unsigned int token;
;   30	    uint8_t ret = VALID;
	LD	(IX+-1),255
;   31	
;   32	    ti_Rewind(ice.inPrgm);
	LD	A,(_ice+40833)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Rewind
	POP	BC
;   33	
;   34	    // Do things based on the token
;   35	    while ((token = getc()) != EOF) {
	JR	L_4
L_5:
;   36	        if ((uint8_t)token != tii) {
	LD	A,(IX+-4)
	CP	A,44
	JR	Z,L_3
;   37	            ice.usedCodeAfterHeader = true;
	LD	A,1
	LD	(_ice+40837),A
;   38	        }
L_3:
;   39	        if ((ret = (*functions[(uint8_t)token])(token)) != VALID) {
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	BC,_functions
	ADD	HL,BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	IY,(HL)
	CALL	__indcall
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	NZ,L_12
;   40	            break;
;   41	        }
;   42	    }
L_4:
	CALL	_getc
	LD	(IX+-4),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_5
L_12:
;   43	
;   44	    // If the last token is not "Return", write a "ret" to the program
;   45	    if (ret == VALID && !ice.lastTokenIsReturn) {
	LD	A,(IX+-1)
	CP	A,255
	JR	NZ,L_13
	LD	A,(_ice+40839)
	OR	A,A
	JR	NZ,L_13
;   46	        RET();
	LD	HL,(_ice+40826)
	LD	(HL),201
	LD	BC,(_ice+40826)
	INC	BC
	LD	(_ice+40826),BC
;   47	    }
L_13:
;   48	
;   49	    return ret;
	LD	A,(IX+-1)
;   50	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseProgram ***************************
;Name                         Addr/Register   Size   Type
;_getc                               IMPORT  -----   function
;_functions                          IMPORT    768   variable
;_ice                                IMPORT  40840   variable
;_ti_Rewind                          IMPORT  -----   function
;token                                 IX-4      3   variable
;ret                                   IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;   51	
;   52	/* Static functions */
;   53	
;   54	static uint8_t parseExpression(unsigned int token) {
_parseExpression:
	LD	HL,-78
	CALL	__frameset
;   55	    const uint8_t *outputStack    = (uint8_t*)0xD62C00;
;   56	    const uint8_t *stack          = (uint8_t*)0xD64000;
;   57	    const uint8_t *tempCFunctions = stack;
;   58	    unsigned int outputElements   = 0;
	LD	BC,0
	LD	(IX+-3),BC
;   59	    unsigned int stackElements    = 0;
	LD	(IX+-6),BC
;   60	    unsigned int loopIndex, temp;
;   61	    uint8_t index = 0, nestedDets = 0;
	LD	(IX+-24),0
	LD	(IX+-10),0
;   62	    uint8_t amountOfArgumentsStack[20];
;   63	    uint8_t *amountOfArgumentsStackPtr = amountOfArgumentsStack;
	LEA	BC,IX+-72
	LD	(IX+-13),BC
;   64	    uint8_t stackToOutputReturn;
;   65	
;   66	    // Setup pointers
;   67	    element_t *outputPtr = (element_t*)outputStack;
;   68	    element_t *stackPtr = (element_t*)stack;
;   69	    element_t *outputCurr, *outputPrev, *outputPrevPrev;
;   70	    element_t *stackCurr, *stackPrev = NULL;
	LD	BC,0
	LD	(IX+-20),BC
;   71	    
;   72	    /*
;   73	        General explanation stacks:
;   74	        - Each entry consists of 4 bytes, the type and the operand
;   75	        - Type: first 4 bits is the amount of nested det()'s, the last 4 the type, like number, variable, function, operator etc
;   76	        - The operand is either a 3-byte number or consists of 3 bytes:
;   77	            - The first byte = the operan: function/variable/operator
;   78	            - If it's a function then the second byte is the amount of arguments for that function
;   79	    */
;   80	
;   81	    while (token != EOF && token != tEnter) {
	JR	L_74
L_75:
;   82	        uint8_t tok;
;   83	        outputCurr = &outputPtr[outputElements];
	LD	HL,(IX+-3)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-9),HL
;   84	        stackCurr  = &stackPtr[stackElements];
	LD	HL,(IX+-6)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14041088
	ADD	HL,BC
	LD	(IX+-23),HL
;   85	        tok = (uint8_t)token;
	LD	A,(IX+6)
	LD	(IX+-17),A
;   86	
;   87	        // Process a number
;   88	        if (tok >= t0 && tok <= t9) {
	CP	A,48
	JR	C,L_72
	LD	A,57
	CP	A,(IX+-17)
	JR	C,L_72
;   89	            uint24_t output = token - t0;
	LD	IY,(IX+6)
	LEA	IY,IY+-48
	LD	(IX+-40),IY
;   90	            while ((uint8_t)(token = getc()) >= t0 && (uint8_t)token <= t9) {
	JR	L_18
L_19:
;   91	                output = output*10 + (uint8_t)token - t0;
	LD	HL,(IX+-40)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+-40)
	ADD	HL,BC
	ADD	HL,HL
	LD	BC,HL
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LEA	IY,IY+-48
	LD	(IX+-40),IY
;   92	            }
L_18:
	CALL	_getc
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,48
	JR	C,L_20
	LD	B,(IX+6)
	LD	A,57
	CP	A,B
	JR	NC,L_19
L_20:
;   93	            outputCurr->type = TYPE_NUMBER + (nestedDets << 4);
	LD	A,(IX+-10)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	IY,(IX+-9)
	LD	(IY+0),A
;   94	            outputCurr->operand = output;
	LD	BC,(IX+-40)
	LD	(IY+1),BC
;   95	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;   96	
;   97	            // Don't grab a new token
;   98	            continue;
	JR	L_74
;   99	        }
;  100	
;  101	        // Process a variable
;  102	        else if (tok >= tA && tok <= tTheta) {
L_72:
	LD	A,(IX+-17)
	CP	A,65
	JR	C,L_70
	LD	A,91
	CP	A,(IX+-17)
	JR	C,L_70
;  103	            outputCurr->type = TYPE_VARIABLE + (nestedDets << 4);
	LD	A,(IX+-10)
	LD	IY,(IX+-9)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	INC	A
	LD	(IY+0),A
;  104	            outputCurr->operand = tok - tA;
	LD	A,(IX+-17)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-65
	LD	IY,(IX+-9)
	LD	(IY+1),BC
;  105	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  106	        }
;  107	        
;  108	        // Parse an operator
;  109	        else if ((index = getIndexOfOperator(tok))) {
	JR	L_73
L_70:
	LD	C,(IX+-17)
	LD	B,0
	PUSH	BC
	CALL	_getIndexOfOperator
	POP	BC
	LD	(IX+-24),A
	OR	A,A
	JR	Z,L_68
;  110	            // If the token is ->, move the entire stack to the output, instead of checking the precedence
;  111	            if (tok == tStore) {
	LD	A,(IX+-17)
	CP	A,4
	JR	NZ,L_33
;  112	                // The last argument is not counted yet, so increment
;  113	                (*amountOfArgumentsStackPtr)++;
	LD	HL,(IX+-13)
	LD	A,(HL)
	INC	A
	LD	HL,(IX+-13)
	LD	(HL),A
;  114	                
;  115	                // Move entire stack to output
;  116	                stackToOutputReturn = 1;
	LD	(IX+-26),1
;  117	                goto stackToOutput;
	JR	L_129
;  118	stackToOutputReturn1:
L_26:
;  119	
;  120	                // We are in not in any nested det() anymore
;  121	                nestedDets = 0;
	LD	(IX+-10),0
;  122	            }
;  123	            
;  124	            // Move the stack to the output as long...
;  125	            while (stackElements) {
	JR	L_33
L_34:
;  126	                stackPrev = &stackPtr[stackElements-1];
	LD	IY,(IX+-6)
	LEA	BC,IY+-1
	LD	(IX+-46),BC
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14041088
	ADD	HL,BC
	LD	(IX+-20),HL
;  127	                outputCurr = &outputPtr[outputElements];
	LD	HL,(IX+-3)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-9),HL
;  128	                
;  129	                // Move the last entry of the stack to the ouput if it's precedence is greater than the precedence of the current token
;  130	                if ((stackPrev->type & 15) == TYPE_OPERATOR && operatorPrecedence[index - 1] <= operatorPrecedence[getIndexOfOperator(stackPrev->operand) - 1]) {
	LD	IY,(IX+-20)
	LD	A,(IY+0)
	AND	A,15
	CP	A,14
	JR	NZ,L_37
	LD	IY,(IX+-20)
	LD	C,(IY+1)
	LD	B,0
	PUSH	BC
	CALL	_getIndexOfOperator
	POP	BC
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,_operatorPrecedence
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-24)
	UEXT	HL
	LD	L,A
	DEC	HL
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L_37
;  131	                    outputCurr->type = stackPrev->type;
	LD	IY,(IX+-20)
	LD	A,(IY+0)
	LD	IY,(IX+-9)
	LD	(IY+0),A
;  132	                    outputCurr->operand = stackPrev->operand;
	LD	IY,(IX+-20)
	LD	BC,(IY+1)
	LD	IY,(IX+-9)
	LD	(IY+1),BC
;  133	                    stackElements--;
	LD	BC,(IX+-46)
	LD	(IX+-6),BC
;  134	                    outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  135	                } else {
;  136	                    break;
;  137	                }
;  138	            }
L_33:
	LD	BC,0
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_34
L_37:
;  139	            
;  140	            // Push the operator to the stack
;  141	            stackCurr = &stackPtr[stackElements++];
	LD	HL,(IX+-6)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14041088
	ADD	HL,BC
	LD	(IX+-23),HL
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  142	            stackCurr->type = TYPE_OPERATOR + (nestedDets << 4);
	LD	A,(IX+-10)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,14
	LD	IY,(IX+-23)
	LD	(IY+0),A
;  143	            stackCurr->operand = token;
	LD	BC,(IX+6)
	LD	(IY+1),BC
;  144	        }
;  145	        
;  146	        // Push a left parenthesis
;  147	        else if (tok == tLParen) {
	JR	L_73
L_68:
	LD	A,(IX+-17)
	CP	A,16
	JR	NZ,L_66
;  148	            stackCurr->type = TYPE_FUNCTION + (nestedDets << 4);
	LD	A,(IX+-10)
	LD	IY,(IX+-23)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,15
	LD	(IY+0),A
;  149	            stackCurr->operand = token;
	LD	BC,(IX+6)
	LD	(IY+1),BC
;  150	            stackElements++;
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  151	        }
;  152	        
;  153	        // Pop a right parenthesis
;  154	        else if (tok == tRParen || tok == tComma) {
	JR	L_73
L_66:
	LD	A,(IX+-17)
	CP	A,17
	JR	Z,L_44
	LD	A,(IX+-17)
	CP	A,43
	JR	Z,L_44
	JR	L_64
;  155	            // Move until stack is empty or a function is encountered
;  156	            while (stackElements) {
L_45:
;  157	                stackPrev = &stackPtr[stackElements-1];
	LD	IY,(IX+-6)
	LEA	BC,IY+-1
	LD	(IX+-49),BC
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14041088
	ADD	HL,BC
	LD	(IX+-20),HL
;  158	                outputCurr = &outputPtr[outputElements];
	LD	HL,(IX+-3)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-9),HL
;  159	                if ((stackPrev->type & 15) != TYPE_FUNCTION) {
	LD	IY,(IX+-20)
	LD	A,(IY+0)
	LD	(IX+-25),A
	AND	A,15
	CP	A,15
	JR	Z,L_47
;  160	                    outputCurr->type = stackPrev->type;
	LD	A,(IX+-25)
	LD	IY,(IX+-9)
	LD	(IY+0),A
;  161	                    outputCurr->operand = stackPrev->operand;
	LD	IY,(IX+-20)
	LD	BC,(IY+1)
	LD	IY,(IX+-9)
	LD	(IY+1),BC
;  162	                    stackElements--;
	LD	BC,(IX+-49)
	LD	(IX+-6),BC
;  163	                    outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  164	                } else {
;  165	                    break;
;  166	                }
;  167	            }
L_44:
	LD	BC,0
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_45
L_47:
;  168	            
;  169	            // No matching left parenthesis
;  170	            if (!stackElements) {
	LD	BC,0
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_49
;  171	                return E_EXTRA_RPAREN;
	LD	A,4
	JR	L_134
;  172	            }
L_49:
;  173	            
;  174	            // Increment the amount of arguments for that function
;  175	            (*amountOfArgumentsStackPtr)++;
	LD	HL,(IX+-13)
	LD	A,(HL)
	INC	A
	LD	HL,(IX+-13)
	LD	(HL),A
;  176	            
;  177	            // If the right parenthesis belongs to a function, move the function as well
;  178	            if (tok == tRParen && stackPrev->operand != tLParen) {
	LD	A,(IX+-17)
	CP	A,17
	JR	NZ,L_73
	LD	IY,(IX+-20)
	LD	BC,(IY+1)
	LD	(IX+-29),BC
	LD	HL,BC
	LD	BC,16
	OR	A,A
	SBC	HL,BC
	JR	Z,L_73
;  179	                outputCurr->type = stackPrev->type;
	LD	IY,(IX+-20)
	LD	A,(IY+0)
	LD	IY,(IX+-9)
	LD	(IY+0),A
;  180	                outputCurr->operand = stackPrev->operand + ((*amountOfArgumentsStackPtr--) << 8);
	LD	BC,(IX+-13)
	LD	(IX+-75),BC
	LD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,8
	CALL	__ishl_b
	LD	BC,(IX+-29)
	ADD	HL,BC
	LD	(IY+1),HL
	LD	IY,(IX+-13)
	LEA	BC,IY+-1
	LD	(IX+-13),BC
;  181	                stackElements--;
	LD	IY,(IX+-6)
	LEA	IY,IY+-1
	LD	(IX+-6),IY
;  182	                outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  183	                if ((uint8_t)stackPrev->operand == tDet) {
	LD	A,(IX+-29)
	CP	A,179
	JR	NZ,L_73
;  184	                    nestedDets--;
	DEC	(IX+-10)
;  185	                }
;  186	            }
;  187	        } 
;  188	        
;  189	        // Process a function which returns something (not(), sqrt(), det(...))
;  190	        else if (strchr(implementedFunctions, tok)) {
	JR	L_73
L_64:
	LD	A,(IX+-17)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,_implementedFunctions
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_62
;  191	            *++amountOfArgumentsStackPtr = 0;
	LD	BC,(IX+-13)
	INC	BC
	LD	(IX+-13),BC
	LD	HL,BC
	LD	(HL),0
;  192	            if (tok == tDet) {
	LD	A,(IX+-17)
	CP	A,179
	JR	NZ,L_59
;  193	                nestedDets++;
	INC	(IX+-10)
;  194	            }
L_59:
;  195	            stackCurr->type = TYPE_FUNCTION + (nestedDets << 4);
	LD	A,(IX+-10)
	LD	IY,(IX+-23)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,15
	LD	(IY+0),A
;  196	            stackCurr->operand = token;
	LD	BC,(IX+6)
	LD	(IY+1),BC
;  197	            stackElements++;
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  198	        } 
;  199	        
;  200	        // Oops, unknown token...
;  201	        else {
	JR	L_73
L_62:
;  202	            return E_UNIMPLEMENTED;
	XOR	A,A
	JR	L_134
;  203	        }
L_73:
;  204	       
;  205	        token = getc();
	CALL	_getc
	LD	(IX+6),HL
;  206	    }
L_74:
	LD	BC,16777215
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_77
	LD	BC,63
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_75
L_77:
;  207	    
;  208	    // The last argument is not counted yet, so increment
;  209	    (*amountOfArgumentsStackPtr)++;
	LD	HL,(IX+-13)
	LD	A,(HL)
	INC	A
	LD	HL,(IX+-13)
	LD	(HL),A
;  210	    
;  211	    // Move entire stack to output
;  212	    stackToOutputReturn = 2;
	LD	(IX+-26),2
;  213	    goto stackToOutput;
	JR	L_129
;  214	stackToOutputReturn2:
L_78:
;  215	
;  216	    // Remove stupid things like 2+5
;  217	    for (loopIndex = 2; loopIndex < outputElements; loopIndex++) {
	LD	BC,2
	LD	(IX+-16),BC
	JR	L_86
L_84:
;  218	        outputPrevPrev = &outputPtr[loopIndex-2];
	LD	IY,(IX+-16)
	LEA	HL,IY+-2
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-34),HL
;  219	        outputPrev = &outputPtr[loopIndex-1];
	LEA	BC,IY+-1
	LD	(IX+-52),BC
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-43),HL
;  220	        outputCurr = &outputPtr[loopIndex];
	LD	HL,(IX+-16)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-9),HL
;  221	        
;  222	        // Check if the types are number | number | operator
;  223	        if ((outputPrevPrev->type & 15) == TYPE_NUMBER && (outputPrev->type & 15) == TYPE_NUMBER && (outputCurr->type & 15) == TYPE_OPERATOR) {
	LD	IY,(IX+-34)
	LD	A,(IY+0)
	AND	A,15
	JR	NZ,L_85
	LD	IY,(IX+-43)
	LD	A,(IY+0)
	AND	A,15
	JR	NZ,L_85
	LD	IY,(IX+-9)
	LD	A,(IY+0)
	AND	A,15
	CP	A,14
	JR	NZ,L_85
;  224	            // If yes, execute the operator, and store it in the first entry, and remove the other 2
;  225	            outputPrevPrev->operand = executeOperator(outputPrevPrev->operand, outputPrev->operand, (uint8_t)outputCurr->operand);
	LD	IY,(IX+-9)
	LD	C,(IY+1)
	LD	B,0
	PUSH	BC
	LD	IY,(IX+-43)
	LD	BC,(IY+1)
	PUSH	BC
	LD	IY,(IX+-34)
	LD	BC,(IY+1)
	PUSH	BC
	CALL	_executeOperator
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+-34)
	LD	(IY+1),HL
;  226	            memcpy(outputPrev, &outputPtr[loopIndex+1], (outputElements-1)*4);
	LD	IY,(IX+-3)
	LEA	HL,IY+-1
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,(IX+-16)
	INC	HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-43)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  227	            outputElements -= 2;
	LD	IY,(IX+-3)
	LEA	IY,IY+-2
	LD	(IX+-3),IY
;  228	            loopIndex--;
	LD	BC,(IX+-52)
	LD	(IX+-16),BC
;  229	        }
;  230	    }
L_85:
	LD	BC,(IX+-16)
	INC	BC
	LD	(IX+-16),BC
L_86:
	LD	BC,(IX+-3)
	LD	HL,(IX+-16)
	OR	A,A
	SBC	HL,BC
	JR	C,L_84
;  231	    
;  232	    // Check if the expression is valid
;  233	    if (outputElements == 1) {
	LD	BC,1
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
;  234	        outputCurr = &outputPtr[0];
	LD	BC,14035968
	LD	(IX+-9),BC
;  235	        
;  236	        // Expression is only a single number
;  237	        if (outputCurr->type == TYPE_NUMBER) {
	LD	A,(14035968)
	OR	A,A
	JR	NZ,L_106
;  238	            // This boolean is set, because loops may be optimized when the condition is a number
;  239	            ice.exprOutputIsNumber = true;
	LD	A,1
	LD	(_ice+40838),A
;  240	            LD_HL_IMM(outputCurr->operand);
	LD	HL,(_ice+40826)
	LD	(HL),33
	LD	BC,(_ice+40826)
	INC	BC
	LD	(_ice+40826),BC
	LD	HL,(_ice+40826)
	LD	BC,(14035969)
	LD	(HL),BC
	LD	IY,(_ice+40826)
	LEA	BC,IY+3
	LD	(_ice+40826),BC
	JR	L_107
;  241	        } 
;  242	        
;  243	        // Expression is only a variable
;  244	        else if (outputCurr->type == TYPE_VARIABLE) {
L_106:
	LD	A,(14035968)
	CP	A,1
	JR	NZ,L_104
;  245	            LD_HL_IND_IX_OFF(outputCurr->operand);
	LD	HL,(_ice+40826)
	LD	(HL),221
	INC	HL
	LD	(HL),39
	LD	IY,(_ice+40826)
	LEA	BC,IY+2
	LD	(_ice+40826),BC
	LD	A,(14035969)
	LD	HL,(_ice+40826)
	LD	(HL),A
	LD	BC,(_ice+40826)
	INC	BC
	LD	(_ice+40826),BC
	JR	L_107
;  246	        } 
;  247	        
;  248	        // Expression is only a function without arguments that returns something (getKey, rand)
;  249	        else if (outputCurr->type == TYPE_FUNCTION_RETURN) {
L_104:
	LD	A,(14035968)
	CP	A,2
	JR	NZ,L_102
;  250	            insertFunctionReturn(outputCurr->operand, OUTPUT_IN_HL, NO_PUSH);
	LD	BC,0
	PUSH	BC
	LD	A,(14035969)
	LD	C,A
	LD	DE,2
	PUSH	DE
	LD	B,0
	PUSH	BC
	CALL	_insertFunctionReturn
	POP	BC
	POP	BC
	POP	BC
;  251	        }
;  252	        
;  253	        // Expression is an empty function or operator, i.e. not(, +
;  254	        else {
	JR	L_107
L_102:
;  255	            return E_SYNTAX;
	LD	A,5
	JR	L_134
;  256	        }
L_107:
;  257	        return VALID;
	LD	A,255
	JR	L_134
;  258	    }
;  259	    
;  260	    // This can only happen with a function with a single argument, i.e. det(X), not(X)
;  261	    else if (outputElements == 2) {
L_111:
	LD	BC,2
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_113
;  262	        outputCurr = &outputPtr[1];
	LD	BC,14035972
	LD	(IX+-9),BC
;  263	        
;  264	        // It must be a function with a single argument
;  265	        if ((outputCurr->type & 15) != TYPE_FUNCTION) {
	LD	IY,(IX+-9)
	LD	A,(IY+0)
	AND	A,15
	CP	A,15
	JR	Z,L_113
;  266	            return E_SYNTAX;
	LD	A,5
	JR	L_134
;  267	        }
;  268	        
;  269	        // TODO
;  270	    }
L_113:
;  271	    
;  272	    // Parse the expression in postfix notation!
;  273	    nestedDets = 0;
	LD	(IX+-10),0
;  274	    for (loopIndex = 1; loopIndex < outputElements; loopIndex++) {
	LD	BC,1
	LD	(IX+-16),BC
	JR	L_123
L_121:
;  275	        uint8_t typeMasked;
;  276	
;  277	        outputCurr = &outputPtr[loopIndex];
	LD	HL,(IX+-16)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-9),HL
;  278	        typeMasked = outputCurr->type & 15;
	LD	IY,(IX+-9)
	LD	A,(IY+0)
	LD	(IX+-30),A
	AND	A,15
	LD	(IX+-31),A
;  279	
;  280	        // Parse an operator with 2 arguments
;  281	        if (typeMasked == TYPE_OPERATOR) {
	CP	A,14
	JR	NZ,L_120
;  282	            // Yay, we are entering a det() function (#notyay), so store it elsewhere!
;  283	            if ((outputCurr->type & 240) != nestedDets) {
	LD	A,(IX+-30)
	AND	A,240
	CP	A,(IX+-10)
	JR	Z,L_116
;  284	                // Push the old programPtr
;  285	                push((uint24_t)ice.programPtr);
	LD	BC,(_ice+40826)
	PUSH	BC
	CALL	_push
	POP	BC
;  286	                nestedDets = outputCurr->type & 240;
	LD	IY,(IX+-9)
	LD	A,(IY+0)
	AND	A,240
	LD	(IX+-10),A
;  287	                
;  288	                // Place the new code at a temp location
;  289	                ice.programPtr = tempCFunctions + (500 * (nestedDets >> 4));
	UEXT	HL
	LD	L,A
	LD	A,4
	CALL	__ishrs_b
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14041088
	ADD	HL,BC
	LD	(_ice+40826),HL
;  290	            }
L_116:
;  291	            parseOperator(&outputPtr[loopIndex-2], &outputPtr[loopIndex-1], outputCurr);
	LD	BC,(IX+-9)
	PUSH	BC
	LD	IY,(IX+-16)
	LEA	HL,IY+-1
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	PUSH	HL
	LEA	HL,IY+-2
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	PUSH	HL
	CALL	_parseOperator
	POP	BC
	POP	BC
	POP	BC
;  292	            // Cleanup
;  293	        } 
;  294	        
;  295	        // Parse a function with X arguments
;  296	        else if (typeMasked == TYPE_FUNCTION) {
	JR	L_122
L_120:
	LD	A,(IX+-31)
	CP	A,15
	JR	NZ,L_122
;  297	            // TODO
;  298	            
;  299	            if ((uint8_t)outputCurr->operand == tDet) {
	LD	IY,(IX+-9)
	LD	A,(IY+1)
	CP	A,179
	JR	NZ,L_122
;  300	                ice.programPtr = (uint8_t *)pop();
	CALL	_pop
	LD	(_ice+40826),HL
;  301	            }
;  302	        }
;  303	    }
L_122:
	LD	BC,(IX+-16)
	INC	BC
	LD	(IX+-16),BC
L_123:
	LD	BC,(IX+-3)
	LD	HL,(IX+-16)
	OR	A,A
	SBC	HL,BC
	JR	C,L_121
;  304	
;  305	    // Actual return here
;  306	    return VALID;
	LD	A,255
	JR	L_134
;  307	
;  308	    // Duplicated function opt
;  309	stackToOutput:
;  310	
;  311	    // Move entire stack to output
;  312	    while (stackElements) {
L_130:
;  313	        outputCurr = &outputPtr[outputElements++];
	LD	HL,(IX+-3)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14035968
	ADD	HL,BC
	LD	(IX+-9),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  314	        stackPrev = &stackPtr[--stackElements];
	LD	IY,(IX+-6)
	LEA	BC,IY+-1
	LD	(IX+-6),BC
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,14041088
	ADD	HL,BC
	LD	(IX+-20),HL
;  315	        outputCurr->type = stackPrev->type;
	LD	IY,(IX+-20)
	LD	A,(IY+0)
	LD	IY,(IX+-9)
	LD	(IY+0),A
;  316	        temp = stackPrev->operand;
;  317	        
;  318	        // If it's a function, add the amount of arguments as well
;  319	        if ((stackPrev->type & 15) == TYPE_FUNCTION) {
	AND	A,15
	CP	A,15
	LD	IY,(IX+-20)
	LD	BC,(IY+1)
	LD	(IX+-37),BC
	JR	NZ,L_128
;  320	            temp += (*amountOfArgumentsStackPtr--) << 8;
	LD	BC,(IX+-13)
	LD	(IX+-78),BC
	LD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,8
	CALL	__ishl_b
	LD	BC,(IX+-37)
	ADD	HL,BC
	LD	(IX+-37),HL
	LD	IY,(IX+-13)
	LEA	IY,IY+-1
	LD	(IX+-13),IY
;  321	        }
L_128:
;  322	
;  323	        outputCurr->operand = temp;
	LD	BC,(IX+-37)
	LD	IY,(IX+-9)
	LD	(IY+1),BC
;  324	    }
L_129:
	LD	BC,0
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_130
;  325	    
;  326	    // Select correct return location
;  327	    if (stackToOutputReturn == 2) {
	LD	A,(IX+-26)
	CP	A,2
	JR	Z,L_78
	JR	L_26
;  328	        goto stackToOutputReturn2;
;  329	    }
;  330	
;  331	    goto stackToOutputReturn1;
;  332	}
L_134:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseExpression ***************************
;Name                         Addr/Register   Size   Type
;_pop                                IMPORT  -----   function
;_parseOperator                      IMPORT  -----   function
;_push                               IMPORT  -----   function
;_insertFunctionReturn               IMPORT  -----   function
;_ice                                IMPORT  40840   variable
;_memcpy                             IMPORT  -----   function
;_executeOperator                    IMPORT  -----   function
;_implementedFunctions               STATIC      7   variable
;_strchr                             IMPORT  -----   function
;_operatorPrecedence                 IMPORT  unknown variable
;_getIndexOfOperator                 IMPORT  -----   function
;_getc                               IMPORT  -----   function
;amountOfArgumentsStack               IX-72     20   variable
;G_5                                  IX-52      3   variable
;G_2                                  IX-49      3   variable
;G_0                                  IX-46      3   variable
;outputPrev                           IX-43      3   variable
;output                               IX-40      3   variable
;temp                                 IX-37      3   variable
;outputPrevPrev                       IX-34      3   variable
;typeMasked                           IX-31      1   variable
;G_9                                  IX-30      1   variable
;G_3                                  IX-29      3   variable
;stackToOutputReturn                  IX-26      1   variable
;G_1                                  IX-25      1   variable
;index                                IX-24      1   variable
;stackCurr                            IX-23      3   variable
;stackPrev                            IX-20      3   variable
;tok                                  IX-17      1   variable
;loopIndex                            IX-16      3   variable
;amountOfArgumentsStackPtr            IX-13      3   variable
;nestedDets                           IX-10      1   variable
;outputCurr                            IX-9      3   variable
;stackElements                         IX-6      3   variable
;outputElements                        IX-3      3   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 87 (bytes)
;       Spill Code: 0 (instruction)


;  333	
;  334	static uint8_t functionI(unsigned int token) {
_functionI:
	LD	HL,-44
	CALL	__frameset
;  335	    uint8_t a = 0, b = 0, outputByte, tok;
	LD	(IX+-2),0
	LD	(IX+-3),0
;  336	    const char *dataString;
;  337	    const uint8_t colorTable[16] = {255,24,224,0,248,36,227,97,9,19,230,255,181,107,106,74};
	LEA	DE,IX+-35
	LD	HL,_0temp135
	LD	BC,16
	LDIR	
;  338	    unsigned int offset;
;  339	
;  340	    // Only get the output name, icon or description at the top of your program
;  341	    if (!ice.usedCodeAfterHeader) {
	LD	A,(_ice+40837)
	OR	A,A
	JR	NZ,L_173
;  342	        // Get the output name
;  343	        if (!ice.gotName) {
	LD	A,(_ice+40835)
	OR	A,A
	JR	NZ,L_170
;  344	            while ((token = getc()) != EOF && (uint8_t)token != tEnter && a < 9) {
	JR	L_139
L_140:
;  345	                ice.outName[a++] = (uint8_t)token;
	LD	B,(IX+6)
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	DE,_ice
	ADD	HL,DE
	LD	(HL),B
	INC	(IX+-2)
;  346	            }
L_139:
	CALL	_getc
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_141
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_141
	LD	A,(IX+-2)
	CP	A,9
	JR	C,L_140
L_141:
;  347	            ice.gotName = true;
	LD	A,1
	LD	(_ice+40835),A
;  348	            return VALID;
	LD	A,255
	JR	L_177
;  349	        }
;  350	
;  351	        // Get the icon and description
;  352	        else if (!ice.gotIconDescription) {
L_170:
	LD	A,(_ice+40836)
	OR	A,A
	JR	NZ,L_168
;  353	            // Move header to take place for the icon and description, setup pointer
;  354	            memcpy(ice.headerData + 350, ice.headerData, 116);
	LD	BC,_ice+20
	LD	(IX+-13),BC
	LD	(IX+-38),BC
	LD	BC,116
	PUSH	BC
	LD	BC,(IX+-38)
	PUSH	BC
	LD	HL,(IX+-38)
	LD	BC,350
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  355	            ice.headerPtr = ice.headerData;
	LD	BC,(IX+-13)
	LD	(_ice+40823),BC
;  356	            
;  357	            // Insert "jp <random>" and Cesium header
;  358	            *ice.headerPtr = OP_JP;
	LD	HL,(_ice+40823)
	LD	(HL),195
;  359	            *(uint24_t*)(ice.headerPtr+4) = 0x101001;
	LD	IY,(_ice+40823)
	LEA	HL,IY+4
	LD	BC,1052673
	LD	(HL),BC
;  360	            ice.headerPtr += 7;
	LD	IY,(_ice+40823)
	LEA	BC,IY+7
	LD	(_ice+40823),BC
;  361	            
;  362	            // Icon should start with a "
;  363	            if ((uint8_t)getc() != tString) {
	CALL	_getc
	LD	A,L
	CP	A,42
	JR	Z,L_151
;  364	                return E_WRONG_ICON;
	LD	A,6
	JR	L_177
;  365	            }
;  366	
;  367	            // Get hexadecimal
;  368	            do {
L_151:
;  369	                tok = (uint8_t)getc();
	CALL	_getc
	LD	(IX+-1),L
;  370	                if (tok >= t0 && tok <= t9) {
	LD	A,(IX+-1)
	CP	A,48
	JR	C,L_148
	LD	A,57
	CP	A,(IX+-1)
	JR	C,L_148
;  371	                    outputByte = tok - t0;
	LD	A,(IX+-1)
	SUB	A,48
	LD	(IX+-4),A
;  372	                } else if (tok >= tA && tok <= tF) {
	JR	L_150
L_148:
	LD	A,(IX+-1)
	CP	A,65
	JR	C,L_146
	LD	A,70
	CP	A,(IX+-1)
	JR	C,L_146
;  373	                    outputByte = tok - tA + 10;
	LD	A,(IX+-1)
	ADD	A,-55
	LD	(IX+-4),A
;  374	                } else {
	JR	L_150
L_146:
;  375	                    return E_INVALID_ICON;
	LD	A,7
	JR	L_177
;  376	                }
L_150:
;  377	                *ice.headerPtr++ = colorTable[outputByte];
	LD	BC,(_ice+40823)
	LD	(IX+-41),BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-35
	ADD	HL,BC
	LD	A,(HL)
	LD	HL,(IX+-41)
	LD	(HL),A
	LD	BC,(_ice+40823)
	INC	BC
	LD	(_ice+40823),BC
;  378	            } while (++b);
	INC	(IX+-3)
	LD	A,(IX+-3)
	OR	A,A
	JR	NZ,L_151
;  379	            
;  380	            // Move on to the description
;  381	            if ((uint8_t)(token = getc()) == tString) {
	CALL	_getc
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,42
	JR	NZ,L_165
;  382	                token = getc();
	CALL	_getc
	LD	(IX+6),HL
;  383	            }
L_165:
;  384	
;  385	            if (token != EOF) {
	LD	BC,16777215
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_166
;  386	                
;  387	                if ((uint8_t)token != tEnter) {
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_163
;  388	                    return E_INVALID_ICON;
	LD	A,7
	JR	L_177
;  389	                }
L_163:
;  390	                
;  391	                // Check if there is a description
;  392	                if ((token = getc()) == tii) {
	CALL	_getc
	LD	(IX+6),HL
	LD	BC,44
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_162
;  393	                    uint8_t *dataPtr = ti_GetDataPtr(ice.inPrgm);
	LD	A,(_ice+40833)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetDataPtr
	POP	BC
	LD	(IX+-19),HL
;  394	                    
;  395	                    // Grab description
;  396	                    while ((token = getc()) != EOF && (uint8_t)token != tEnter) {
	JR	L_158
L_159:
;  397	                        unsigned int tokLength;
;  398	                        dataString = ti_GetTokenString(&dataPtr, NULL, &tokLength);
	PEA	IX+-10
	LD	BC,0
	PUSH	BC
	PEA	IX+-19
	CALL	_ti_GetTokenString
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-16),HL
;  399	                        memcpy(ice.headerPtr, dataString, tokLength);
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+-16)
	PUSH	BC
	LD	BC,(_ice+40823)
	PUSH	BC
	CALL	_memcpy
;  400	                        ice.headerPtr += tokLength;
	LD	HL,(_ice+40823)
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-10)
	ADD	HL,BC
	LD	(_ice+40823),HL
;  401	                    }
L_158:
	CALL	_getc
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_166
	LD	A,(IX+6)
	CP	A,63
	JR	NZ,L_159
	JR	L_166
;  402	                } else if (token != EOF) {
L_162:
	LD	BC,16777215
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_166
;  403	                    ti_Seek(-1, SEEK_CUR, ice.inPrgm);
	LD	A,(_ice+40833)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  404	                }
;  405	            }
L_166:
;  406	
;  407	            // Don't increment the pointer for now, we will do that later :)
;  408	            *ice.headerPtr = 0;
	LD	HL,(_ice+40823)
	LD	(HL),0
;  409	
;  410	            // Get the correct offset
;  411	            offset = ice.headerPtr - ice.headerData;
	LD	BC,_ice+20
	LD	(IX+-44),BC
	LD	HL,(_ice+40823)
	LD	BC,(IX+-44)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-7),HL
;  412	
;  413	            // Write the right jp offset
;  414	            *(uint24_t*)(ice.headerData+1) = offset + PRGM_START;
	LD	IY,(IX+-44)
	LD	HL,(IX+-7)
	LD	BC,13740161
	ADD	HL,BC
;  415	            
;  416	            // Copy header back, and update the 3 pointers in the C header...
;  417	            memcpy(ice.headerPtr + 1, ice.headerData + 350, 116);
	LD	BC,116
	PUSH	BC
	LD	(IY+1),HL
	LD	HL,(IX+-44)
	LD	BC,350
	ADD	HL,BC
	PUSH	HL
	LD	BC,(_ice+40823)
	INC	BC
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  418	            *(uint24_t*)(ice.headerPtr+2)  += offset;
	LD	IY,(_ice+40823)
	LEA	HL,IY+2
	LD	IY,(_ice+40823)
	LD	HL,(HL)
	LD	BC,(IX+-7)
	ADD	HL,BC
	LD	(IY+2),HL
;  419	            *(uint24_t*)(ice.headerPtr+53) += offset;
	LD	IY,(_ice+40823)
	LEA	HL,IY+53
	LD	IY,(_ice+40823)
	LD	HL,(HL)
	LD	BC,(IX+-7)
	ADD	HL,BC
	LD	(IY+53),HL
;  420	            *(uint24_t*)(ice.headerPtr+66) += offset;
	LD	IY,(_ice+40823)
	LEA	HL,IY+66
	LD	IY,(_ice+40823)
	LD	HL,(HL)
	LD	BC,(IX+-7)
	ADD	HL,BC
	LD	(IY+66),HL
;  421	            ice.headerPtr += 117;
	LD	IY,(_ice+40823)
	LEA	BC,IY+117
	LD	(_ice+40823),BC
;  422	            
;  423	            ice.gotIconDescription = true;
	LD	A,1
	LD	(_ice+40836),A
;  424	            return VALID;
	LD	A,255
	JR	L_177
;  425	        }
;  426	        
;  427	        // Don't return and treat as a comment
;  428	        else {
L_168:
;  429	            ice.usedCodeAfterHeader = true;
	LD	A,1
	LD	(_ice+40837),A
;  430	        }
;  431	    }
;  432	
;  433	    // Treat it as a comment
;  434	    while ((token = getc()) != EOF && token != tEnter);
L_173:
	CALL	_getc
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_176
	LD	BC,63
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_173
L_176:
;  435	
;  436	    return VALID;
	LD	A,255
;  437	}
L_177:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionI ***************************
;Name                         Addr/Register   Size   Type
;_ti_Seek                            IMPORT  -----   function
;_ti_GetTokenString                  IMPORT  -----   function
;_ti_GetDataPtr                      IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_getc                               IMPORT  -----   function
;_ice                                IMPORT  40840   variable
;_0temp135                           STATIC     16   variable
;colorTable                           IX-35     16   variable
;dataPtr                              IX-19      3   variable
;dataString                           IX-16      3   variable
;G_10                                 IX-13      3   variable
;tokLength                            IX-10      3   variable
;offset                                IX-7      3   variable
;outputByte                            IX-4      1   variable
;b                                     IX-3      1   variable
;a                                     IX-2      1   variable
;tok                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 53 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_0temp135:
	DB	255
	DB	24
	DB	224
	DB	0
	DB	248
	DB	36
	DB	227
	DB	97
	DB	9
	DB	19
	DB	230
	DB	255
	DB	181
	DB	107
	DB	106
	DB	74
	SEGMENT CODE
;  438	
;  439	static uint8_t functionPrgm(unsigned int token) {
_functionPrgm:
	CALL	__frameset0
;  440	    return VALID;
	LD	A,255
;  441	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionPrgm ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  442	
;  443	static uint8_t functionCustom(unsigned int token) {
_functionCustom:
	CALL	__frameset0
;  444	    return VALID;
	LD	A,255
;  445	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionCustom ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  446	
;  447	static uint8_t functionIf(unsigned int token) {
_functionIf:
	CALL	__frameset0
;  448	    if ((token = getc()) != EOF && token != tEnter) {
	CALL	_getc
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_182
	LD	BC,63
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_182
;  449	        parseExpression(token);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_parseExpression
	POP	BC
;  450	        return VALID;
	LD	A,255
	JR	L_183
;  451	    } else {
L_182:
;  452	        return E_NO_CONDITION;
	LD	A,2
;  453	    }
;  454	}
L_183:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionIf ***************************
;Name                         Addr/Register   Size   Type
;_getc                               IMPORT  -----   function
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  455	
;  456	static uint8_t functionElseEnd(unsigned int token) {
_functionElseEnd:
	CALL	__frameset0
;  457	    // This should return if in nested block
;  458	    if (!ice.nestedBlocks) {
	LD	A,(_ice+18)
	OR	A,A
	JR	NZ,L_185
;  459	        return E_NO_NESTED_BLOCK;
	LD	A,3
	JR	L_186
;  460	    }
L_185:
;  461	    return E_ELSE_END;
	LD	A,8
;  462	}
L_186:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionElseEnd ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  40840   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  463	
;  464	static uint8_t dummyReturn(unsigned int token) {
_dummyReturn:
	CALL	__frameset0
;  465	    return VALID;
	LD	A,255
;  466	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _dummyReturn ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  467	
;  468	static uint8_t functionWhile(unsigned int token) {
_functionWhile:
	CALL	__frameset0
;  469	    return VALID;
	LD	A,255
;  470	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionWhile ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  471	
;  472	static uint8_t functionRepeat(unsigned int token) {
_functionRepeat:
	CALL	__frameset0
;  473	    return VALID;
	LD	A,255
;  474	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionRepeat ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  475	
;  476	static uint8_t functionFor(unsigned int token) {
_functionFor:
	CALL	__frameset0
;  477	    return VALID;
	LD	A,255
;  478	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionFor ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  479	
;  480	static uint8_t functionReturn(unsigned int token) {
_functionReturn:
	CALL	__frameset0
;  481	    return VALID;
	LD	A,255
;  482	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionReturn ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  483	
;  484	static uint8_t functionLbl(unsigned int token) {
_functionLbl:
	CALL	__frameset0
;  485	    return VALID;
	LD	A,255
;  486	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionLbl ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  487	
;  488	static uint8_t functionGoto(unsigned int token) {
_functionGoto:
	CALL	__frameset0
;  489	    return VALID;
	LD	A,255
;  490	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionGoto ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  491	
;  492	static uint8_t functionPause(unsigned int token) {
_functionPause:
	CALL	__frameset0
;  493	    return VALID;
	LD	A,255
;  494	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionPause ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  495	
;  496	static uint8_t functionInput(unsigned int token) {
_functionInput:
	CALL	__frameset0
;  497	    return VALID;
	LD	A,255
;  498	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionInput ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  499	
;  500	static uint8_t functionDisp(unsigned int token) {
_functionDisp:
	CALL	__frameset0
;  501	    return VALID;
	LD	A,255
;  502	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionDisp ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  503	
;  504	static uint8_t functionOutput(unsigned int token) {
_functionOutput:
	CALL	__frameset0
;  505	    return VALID;
	LD	A,255
;  506	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionOutput ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  507	
;  508	static uint8_t functionClrHome(unsigned int token) {
_functionClrHome:
	CALL	__frameset0
;  509	    return VALID;
	LD	A,255
;  510	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionClrHome ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  511	
;  512	static uint8_t tokenWrongPlace(unsigned int token) {
_tokenWrongPlace:
	CALL	__frameset0
;  513	    return E_WRONG_PLACE;
	LD	A,1
;  514	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenWrongPlace ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  515	
;  516	static uint8_t tokenUnimplemented(unsigned int token) {
_tokenUnimplemented:
	CALL	__frameset0
;  517	    return E_UNIMPLEMENTED;
	XOR	A,A
;  518	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenUnimplemented ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT DATA
_functions:
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenWrongPlace
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_functionI
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenUnimplemented
	DW24	_dummyReturn
	DW24	_tokenWrongPlace
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_functionPrgm
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionCustom
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionIf
	DW24	_tokenUnimplemented
	DW24	_functionElseEnd
	DW24	_functionWhile
	DW24	_functionRepeat
	DW24	_functionFor
	DW24	_functionElseEnd
	DW24	_functionReturn
	DW24	_functionLbl
	DW24	_functionGoto
	DW24	_functionPause
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionInput
	DW24	_tokenUnimplemented
	DW24	_functionDisp
	DW24	_tokenUnimplemented
	DW24	_functionOutput
	DW24	_functionClrHome
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	XREF _pop:ROM
	XREF _push:ROM
	XREF _operatorPrecedence:ROM
	XREF _insertFunctionReturn:ROM
	XREF _parseOperator:ROM
	XREF _executeOperator:ROM
	XREF _getIndexOfOperator:ROM
	XREF _ice:ROM
	XREF _ti_GetDataPtr:ROM
	XREF _ti_GetTokenString:ROM
	XREF _ti_Rewind:ROM
	XREF _ti_Seek:ROM
	XREF _ti_GetC:ROM
	XREF _strchr:ROM
	XREF _memcpy:ROM
	XREF __indcall:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __ishl_b:ROM
	XREF __ishrs_b:ROM
	XDEF _functions
	XDEF _parseProgram
	XDEF _getc
	XDEF _implementedFunctions
;  519	
;  520	uint8_t (*functions[256])(unsigned int) = {
	END
